///--------------------------------------------------------------------------------------------------------------------------------------------------
/// Author: Andrew Chase
/// Date Created: Nov 27th, 2021
/// Description: 
///--------------------------------------------------------------------------------------------------------------------------------------------------

///--------------------------------------------------------------------------------------------------------------------------------------------------
/// INCLUDES
///--------------------------------------------------------------------------------------------------------------------------------------------------
#include "Engine/Core/EngineCommon.h"
#include "Engine/Math/ScalarField3.h"
#include "Engine/Math/Vector3.h"

///--------------------------------------------------------------------------------------------------------------------------------------------------
/// DEFINES
///--------------------------------------------------------------------------------------------------------------------------------------------------

///--------------------------------------------------------------------------------------------------------------------------------------------------
/// ENUMS, TYPEDEFS, STRUCTS, FORWARD DECLARATIONS
///--------------------------------------------------------------------------------------------------------------------------------------------------

///--------------------------------------------------------------------------------------------------------------------------------------------------
/// GLOBALS AND STATICS
///--------------------------------------------------------------------------------------------------------------------------------------------------

///--------------------------------------------------------------------------------------------------------------------------------------------------
/// C FUNCTIONS
///--------------------------------------------------------------------------------------------------------------------------------------------------

///--------------------------------------------------------------------------------------------------------------------------------------------------
/// CLASS IMPLEMENTATIONS
///--------------------------------------------------------------------------------------------------------------------------------------------------

//-------------------------------------------------------------------------------------------------
ScalarField3::~ScalarField3()
{
	SAFE_FREE(m_data);
}


//-------------------------------------------------------------------------------------------------
ScalarField3::ScalarField3(const IntVector3& dimensions, float initialValue)
	: m_dimensions(dimensions)
{
	m_data = (float*)malloc(sizeof(float) * dimensions.x * dimensions.y * dimensions.z);
}


//-------------------------------------------------------------------------------------------------
float ScalarField3::GetValue(const IntVector3& samplePoint) const
{
	return GetValue(samplePoint.x, samplePoint.y, samplePoint.z);
}


//-------------------------------------------------------------------------------------------------
float ScalarField3::GetValue(int xPt, int yPt, int zPt) const
{
	ASSERT_OR_DIE((xPt >= 0 && xPt < m_dimensions.x) && (yPt >= 0 && yPt < m_dimensions.y) && (zPt >= 0 && zPt < m_dimensions.z), "Invalid index!");

	int numPerSlice = m_dimensions.x * m_dimensions.y;
	int index = xPt + yPt * m_dimensions.x + zPt * numPerSlice;
	
	return m_data[index];
}


//-------------------------------------------------------------------------------------------------
void ScalarField3::SetValue(const IntVector3& point, float value)
{
	SetValue(point.x, point.y, point.z, value);
}


//-------------------------------------------------------------------------------------------------
void ScalarField3::SetValue(int xPt, int yPt, int zPt, float value)
{
	ASSERT_OR_DIE((xPt >= 0 && xPt < m_dimensions.x) && (yPt >= 0 && yPt < m_dimensions.y) && (zPt >= 0 && zPt < m_dimensions.z), "Invalid index!");

	int numPerSlice = m_dimensions.x * m_dimensions.y;
	int index = xPt + yPt * m_dimensions.x + zPt * numPerSlice;

	m_data[index] = value;
}
